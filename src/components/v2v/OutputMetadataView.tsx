/**
 * Structured visualization for the "Creating output metadata" pipeline stage.
 *
 * Parses the resulting KubeVirt YAML and presents VM identity, compute resources,
 * firmware, storage (disks + volumes), networking (interfaces + networks),
 * and clock/timer configuration in a readable layout.
 */
import { useMemo, useState } from 'react';
import { SectionHeader } from './shared';

// ── Types ───────────────────────────────────────────────────────────────────

interface VmMetadata {
  name: string;
  labels: Record<string, string>;
}

interface VmResources {
  memory: string;
  cpuCores: number;
}

interface VmDisk {
  name: string;
  bus: string;
}

interface VmVolume {
  name: string;
  path: string;
  type: string; // Disk, DiskOrCreate, etc.
}

interface VmInterface {
  name: string;
  type: string; // bridge, masquerade, etc.
  macAddress: string;
  model: string;
}

interface VmNetwork {
  name: string;
  networkName: string;
}

interface VmTimers {
  [name: string]: Record<string, string>;
}

interface ParsedOutputMetadata {
  apiVersion: string;
  kind: string;
  metadata: VmMetadata;
  firmware: string; // bios or efi
  resources: VmResources;
  features: string[];
  clock: { offset: string; timers: VmTimers };
  disks: VmDisk[];
  volumes: VmVolume[];
  interfaces: VmInterface[];
  networks: VmNetwork[];
  rng: boolean;
  terminationGracePeriod: number;
  generatedBy: string;
  rawYaml: string;
}

// ── Parser ──────────────────────────────────────────────────────────────────

function parseOutputMetadata(lines: string[]): ParsedOutputMetadata {
  const result: ParsedOutputMetadata = {
    apiVersion: '',
    kind: '',
    metadata: { name: '', labels: {} },
    firmware: '',
    resources: { memory: '', cpuCores: 0 },
    features: [],
    clock: { offset: '', timers: {} },
    disks: [],
    volumes: [],
    interfaces: [],
    networks: [],
    rng: false,
    terminationGracePeriod: 0,
    generatedBy: '',
    rawYaml: '',
  };

  // Find the YAML block start
  let yamlStart = -1;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].trim() === '---' || lines[i].trim().startsWith('apiVersion:')) {
      yamlStart = i;
      break;
    }
  }
  if (yamlStart === -1) return result;

  // Collect raw YAML
  const yamlLines = lines.slice(yamlStart);
  result.rawYaml = yamlLines.join('\n');

  // Extract generated-by comment
  for (let i = 0; i < lines.length; i++) {
    const commentMatch = lines[i].match(/^#\s*generated by\s+(.+)/i);
    if (commentMatch) {
      result.generatedBy = commentMatch[1].trim();
      break;
    }
  }

  // Simple indentation-aware YAML parser — tracks context by indentation path
  type Context = 'root' | 'metadata' | 'labels' | 'spec' | 'template' | 'templateSpec'
    | 'domain' | 'firmware' | 'bootloader' | 'resources' | 'requests' | 'clock' | 'timers'
    | 'timerEntry' | 'cpu' | 'devices' | 'disks' | 'diskEntry' | 'diskProp'
    | 'interfaces' | 'ifaceEntry' | 'volumes' | 'volumeEntry' | 'hostDisk'
    | 'networks' | 'networkEntry' | 'features';

  const contextStack: { indent: number; ctx: Context }[] = [{ indent: -1, ctx: 'root' }];

  function currentCtx(): Context {
    return contextStack[contextStack.length - 1].ctx;
  }
  function pushCtx(indent: number, ctx: Context) {
    contextStack.push({ indent, ctx });
  }
  function popToIndent(indent: number) {
    while (contextStack.length > 1 && contextStack[contextStack.length - 1].indent >= indent) {
      contextStack.pop();
    }
  }

  let currentDisk: Partial<VmDisk> = {};
  let currentVolume: Partial<VmVolume> = {};
  let currentIface: Partial<VmInterface> = {};
  let currentNetwork: Partial<VmNetwork> = {};
  let currentTimerName = '';

  for (const line of yamlLines) {
    if (line.trim() === '' || line.trim() === '---' || line.trim().startsWith('#')) continue;

    const indent = line.search(/\S/);
    const trimmed = line.trim();

    // Pop context for lines at same or lesser indent
    popToIndent(indent);

    const ctx = currentCtx();

    // Key-value or key-only
    const kvMatch = trimmed.match(/^(\S[^:]*?):\s*(.*)/);
    const isListItem = trimmed.startsWith('- ');

    if (kvMatch) {
      const key = kvMatch[1].trim();
      const val = kvMatch[2].replace(/^["']|["']$/g, '').trim();

      // Root level
      if (ctx === 'root') {
        if (key === 'apiVersion') result.apiVersion = val;
        else if (key === 'kind') result.kind = val;
        else if (key === 'metadata') pushCtx(indent, 'metadata');
        else if (key === 'spec') pushCtx(indent, 'spec');
      }
      // metadata
      else if (ctx === 'metadata') {
        if (key === 'name') result.metadata.name = val;
        else if (key === 'labels') pushCtx(indent, 'labels');
      }
      // labels
      else if (ctx === 'labels') {
        result.metadata.labels[key] = val;
      }
      // spec → template
      else if (ctx === 'spec') {
        if (key === 'template') pushCtx(indent, 'template');
      }
      // template → spec
      else if (ctx === 'template') {
        if (key === 'spec') pushCtx(indent, 'templateSpec');
      }
      // template spec
      else if (ctx === 'templateSpec') {
        if (key === 'domain') pushCtx(indent, 'domain');
        else if (key === 'volumes') pushCtx(indent, 'volumes');
        else if (key === 'networks') pushCtx(indent, 'networks');
        else if (key === 'terminationGracePeriodSeconds') {
          result.terminationGracePeriod = parseInt(val, 10) || 0;
        }
      }
      // domain
      else if (ctx === 'domain') {
        if (key === 'firmware') pushCtx(indent, 'firmware');
        else if (key === 'resources') pushCtx(indent, 'resources');
        else if (key === 'cpu') pushCtx(indent, 'cpu');
        else if (key === 'devices') pushCtx(indent, 'devices');
      }
      // firmware → bootloader
      else if (ctx === 'firmware') {
        if (key === 'bootloader') pushCtx(indent, 'bootloader');
      }
      // bootloader → bios/efi
      else if (ctx === 'bootloader') {
        if (key === 'bios') result.firmware = 'BIOS';
        else if (key === 'efi') result.firmware = 'UEFI';
      }
      // resources
      else if (ctx === 'resources') {
        if (key === 'clock') pushCtx(indent, 'clock');
        else if (key === 'requests') pushCtx(indent, 'requests');
        else if (key === 'features') pushCtx(indent, 'features');
      }
      // requests
      else if (ctx === 'requests') {
        if (key === 'memory') result.resources.memory = val;
      }
      // clock
      else if (ctx === 'clock') {
        if (key === 'utc') result.clock.offset = 'UTC';
        else if (key === 'timer') pushCtx(indent, 'timers');
      }
      // timers
      else if (ctx === 'timers') {
        currentTimerName = key;
        result.clock.timers[key] = {};
        pushCtx(indent, 'timerEntry');
      }
      // timer entry properties
      else if (ctx === 'timerEntry') {
        result.clock.timers[currentTimerName][key] = val;
      }
      // cpu
      else if (ctx === 'cpu') {
        if (key === 'cores') result.resources.cpuCores = parseInt(val, 10) || 0;
      }
      // devices
      else if (ctx === 'devices') {
        if (key === 'rng') result.rng = true;
        else if (key === 'disks') pushCtx(indent, 'disks');
        else if (key === 'interfaces') pushCtx(indent, 'interfaces');
      }
      // disk entry properties
      else if (ctx === 'diskEntry') {
        if (key === 'name') currentDisk.name = val;
        else if (key === 'disk') pushCtx(indent, 'diskProp');
      }
      // disk bus property
      else if (ctx === 'diskProp') {
        if (key === 'bus') currentDisk.bus = val;
      }
      // interface entry properties
      else if (ctx === 'ifaceEntry') {
        if (key === 'name') currentIface.name = val;
        else if (key === 'bridge') currentIface.type = 'bridge';
        else if (key === 'masquerade') currentIface.type = 'masquerade';
        else if (key === 'sriov') currentIface.type = 'sriov';
        else if (key === 'macAddress') currentIface.macAddress = val;
        else if (key === 'model') currentIface.model = val;
      }
      // volume entry properties
      else if (ctx === 'volumeEntry') {
        if (key === 'name') currentVolume.name = val;
        else if (key === 'hostDisk') pushCtx(indent, 'hostDisk');
      }
      // hostDisk
      else if (ctx === 'hostDisk') {
        if (key === 'path') currentVolume.path = val;
        else if (key === 'type') currentVolume.type = val;
      }
      // network entry properties
      else if (ctx === 'networkEntry') {
        if (key === 'name') currentNetwork.name = val;
        else if (key === 'networkName') currentNetwork.networkName = val;
      }
    }

    // List items
    if (isListItem) {
      const listContent = trimmed.slice(2);

      if (ctx === 'disks') {
        // Flush previous disk
        if (currentDisk.name) {
          result.disks.push({ name: currentDisk.name, bus: currentDisk.bus || '' });
        }
        currentDisk = {};
        pushCtx(indent, 'diskEntry');
        // Inline key-value: "- disk:"
        const inlineKv = listContent.match(/^(\S[^:]*?):\s*(.*)/);
        if (inlineKv) {
          const key = inlineKv[1].trim();
          if (key === 'disk') pushCtx(indent + 2, 'diskProp');
          else if (key === 'name') currentDisk.name = inlineKv[2].replace(/^["']|["']$/g, '').trim();
        }
      } else if (ctx === 'interfaces') {
        // Flush previous interface
        if (currentIface.name) {
          result.interfaces.push({
            name: currentIface.name,
            type: currentIface.type || '',
            macAddress: currentIface.macAddress || '',
            model: currentIface.model || '',
          });
        }
        currentIface = {};
        pushCtx(indent, 'ifaceEntry');
        const inlineKv = listContent.match(/^(\S[^:]*?):\s*(.*)/);
        if (inlineKv) {
          const key = inlineKv[1].trim();
          const val = inlineKv[2].replace(/^["']|["']$/g, '').trim();
          if (key === 'name') currentIface.name = val;
        }
      } else if (ctx === 'volumes') {
        // Flush previous volume
        if (currentVolume.name) {
          result.volumes.push({
            name: currentVolume.name,
            path: currentVolume.path || '',
            type: currentVolume.type || '',
          });
        }
        currentVolume = {};
        pushCtx(indent, 'volumeEntry');
        const inlineKv = listContent.match(/^(\S[^:]*?):\s*(.*)/);
        if (inlineKv) {
          const key = inlineKv[1].trim();
          if (key === 'hostDisk') pushCtx(indent + 2, 'hostDisk');
          else if (key === 'name') currentVolume.name = inlineKv[2].replace(/^["']|["']$/g, '').trim();
        }
      } else if (ctx === 'networks') {
        // Flush previous network
        if (currentNetwork.name) {
          result.networks.push({
            name: currentNetwork.name,
            networkName: currentNetwork.networkName || '',
          });
        }
        currentNetwork = {};
        pushCtx(indent, 'networkEntry');
        const inlineKv = listContent.match(/^(\S[^:]*?):\s*(.*)/);
        if (inlineKv) {
          const key = inlineKv[1].trim();
          const val = inlineKv[2].replace(/^["']|["']$/g, '').trim();
          if (key === 'networkName') currentNetwork.networkName = val;
          else if (key === 'name') currentNetwork.name = val;
        }
      }
    }
  }

  // Flush last entries
  if (currentDisk.name) result.disks.push({ name: currentDisk.name, bus: currentDisk.bus || '' });
  if (currentIface.name) result.interfaces.push({ name: currentIface.name, type: currentIface.type || '', macAddress: currentIface.macAddress || '', model: currentIface.model || '' });
  if (currentVolume.name) result.volumes.push({ name: currentVolume.name, path: currentVolume.path || '', type: currentVolume.type || '' });
  if (currentNetwork.name) result.networks.push({ name: currentNetwork.name, networkName: currentNetwork.networkName || '' });

  return result;
}

// ── Stage detection ─────────────────────────────────────────────────────────

// eslint-disable-next-line react-refresh/only-export-components
export function isOutputMetadataStage(name: string): boolean {
  const lower = name.toLowerCase();
  return lower.includes('creating') && lower.includes('output') && lower.includes('metadata');
}

// ── Component ───────────────────────────────────────────────────────────────

export function OutputMetadataView({ content }: { content: string[] }) {
  const parsed = useMemo(() => parseOutputMetadata(content), [content]);
  const [showYaml, setShowYaml] = useState(false);

  if (!parsed.rawYaml) return null;

  // Build disk→volume mapping
  const volumeMap = new Map(parsed.volumes.map((v) => [v.name, v]));
  // Build interface→network mapping
  const networkMap = new Map(parsed.networks.map((n) => [n.name, n]));

  return (
    <div className="space-y-4">
      {/* Header with VM name + key labels */}
      <div className="border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
        <div className="px-3 py-2.5 bg-slate-50 dark:bg-slate-800/50 border-b border-slate-200 dark:border-slate-700 flex items-center gap-2 flex-wrap">
          <span className="text-xs font-semibold text-slate-700 dark:text-gray-200">
            {parsed.metadata.name || 'Unknown VM'}
          </span>
          {parsed.kind && (
            <span className="px-1.5 py-0.5 rounded bg-indigo-50 dark:bg-indigo-900/20 text-[9px] font-semibold text-indigo-600 dark:text-indigo-300 border border-indigo-200 dark:border-indigo-800">
              {parsed.kind}
            </span>
          )}
          {parsed.apiVersion && (
            <span className="px-1.5 py-0.5 rounded bg-slate-100 dark:bg-slate-700 text-[9px] text-slate-500 dark:text-gray-400">
              {parsed.apiVersion}
            </span>
          )}
          {parsed.firmware && (
            <span className={`px-1.5 py-0.5 rounded text-[9px] font-semibold border ${
              parsed.firmware === 'UEFI'
                ? 'bg-purple-50 dark:bg-purple-900/20 text-purple-600 dark:text-purple-300 border-purple-200 dark:border-purple-800'
                : 'bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-300 border-blue-200 dark:border-blue-800'
            }`}>
              {parsed.firmware}
            </span>
          )}
          {parsed.generatedBy && (
            <span className="ml-auto text-[10px] text-slate-400 dark:text-gray-500 italic">
              {parsed.generatedBy}
            </span>
          )}
        </div>

        {/* Labels */}
        {Object.keys(parsed.metadata.labels).length > 0 && (
          <div className="px-3 py-2 flex flex-wrap gap-1.5">
            {Object.entries(parsed.metadata.labels).map(([key, val]) => {
              const shortKey = key.includes('/') ? key.split('/').pop()! : key;
              return (
                <span
                  key={key}
                  className="inline-flex items-baseline gap-1 px-1.5 py-0.5 rounded text-[10px] bg-slate-50 dark:bg-slate-800/50 text-slate-600 dark:text-gray-300 border border-slate-200 dark:border-slate-700"
                  title={key}
                >
                  <span className="text-slate-400 dark:text-gray-500">{shortKey}:</span>
                  <span className="font-mono">{val}</span>
                </span>
              );
            })}
          </div>
        )}
      </div>

      {/* Compute & Firmware */}
      {(parsed.resources.memory || parsed.resources.cpuCores > 0) && (
        <div>
          <SectionHeader title="Compute Resources" />
          <div className="border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
            <div className="grid grid-cols-[auto_1fr] gap-x-4 gap-y-1.5 px-3 py-2.5 text-[11px]">
              {parsed.resources.cpuCores > 0 && (
                <>
                  <span className="text-slate-400 dark:text-gray-500">CPU Cores</span>
                  <span className="text-slate-700 dark:text-gray-200 font-semibold">{parsed.resources.cpuCores}</span>
                </>
              )}
              {parsed.resources.memory && (
                <>
                  <span className="text-slate-400 dark:text-gray-500">Memory</span>
                  <span className="text-slate-700 dark:text-gray-200 font-semibold">{parsed.resources.memory}</span>
                </>
              )}
              {parsed.firmware && (
                <>
                  <span className="text-slate-400 dark:text-gray-500">Firmware</span>
                  <span className="text-slate-700 dark:text-gray-200">{parsed.firmware}</span>
                </>
              )}
              {parsed.rng && (
                <>
                  <span className="text-slate-400 dark:text-gray-500">RNG Device</span>
                  <span className="text-emerald-600 dark:text-emerald-400 text-[10px]">Enabled</span>
                </>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Storage: Disks ↔ Volumes */}
      {parsed.disks.length > 0 && (
        <div>
          <SectionHeader title={`Storage (${parsed.disks.length} disk${parsed.disks.length > 1 ? 's' : ''})`} />
          <div className="border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
            <table className="w-full text-[11px]">
              <thead>
                <tr className="bg-slate-50 dark:bg-slate-800/50 border-b border-slate-200 dark:border-slate-700">
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">#</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Name</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Bus</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Volume Path</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Type</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-slate-100 dark:divide-slate-800">
                {parsed.disks.map((disk, i) => {
                  const vol = volumeMap.get(disk.name);
                  return (
                    <tr key={i} className="hover:bg-slate-50 dark:hover:bg-slate-800/30">
                      <td className="px-3 py-1.5 text-slate-400 dark:text-gray-500">{i}</td>
                      <td className="px-3 py-1.5 font-mono text-slate-700 dark:text-gray-200">{disk.name}</td>
                      <td className="px-3 py-1.5">
                        <span className={`px-1.5 py-0.5 rounded text-[9px] font-semibold border ${
                          disk.bus === 'virtio'
                            ? 'bg-emerald-50 dark:bg-emerald-900/20 text-emerald-600 dark:text-emerald-300 border-emerald-200 dark:border-emerald-800'
                            : disk.bus === 'scsi'
                              ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-300 border-blue-200 dark:border-blue-800'
                              : 'bg-slate-100 dark:bg-slate-800 text-slate-500 dark:text-gray-400 border-slate-200 dark:border-slate-700'
                        }`}>
                          {disk.bus || 'default'}
                        </span>
                      </td>
                      <td className="px-3 py-1.5 font-mono text-[10px] text-slate-500 dark:text-gray-400 truncate max-w-[300px]" title={vol?.path}>
                        {vol?.path || '--'}
                      </td>
                      <td className="px-3 py-1.5 text-slate-500 dark:text-gray-400">{vol?.type || '--'}</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* Networking: Interfaces ↔ Networks */}
      {parsed.interfaces.length > 0 && (
        <div>
          <SectionHeader title={`Networking (${parsed.interfaces.length} interface${parsed.interfaces.length > 1 ? 's' : ''})`} />
          <div className="border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
            <table className="w-full text-[11px]">
              <thead>
                <tr className="bg-slate-50 dark:bg-slate-800/50 border-b border-slate-200 dark:border-slate-700">
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Network</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Type</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">MAC Address</th>
                  <th className="px-3 py-1.5 text-left text-slate-500 dark:text-gray-400 font-semibold">Model</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-slate-100 dark:divide-slate-800">
                {parsed.interfaces.map((iface, i) => {
                  const net = networkMap.get(iface.name);
                  return (
                    <tr key={i} className="hover:bg-slate-50 dark:hover:bg-slate-800/30">
                      <td className="px-3 py-1.5 text-slate-700 dark:text-gray-200">
                        {net?.networkName || iface.name}
                      </td>
                      <td className="px-3 py-1.5">
                        <span className={`px-1.5 py-0.5 rounded text-[9px] font-semibold border ${
                          iface.type === 'bridge'
                            ? 'bg-sky-50 dark:bg-sky-900/20 text-sky-600 dark:text-sky-300 border-sky-200 dark:border-sky-800'
                            : iface.type === 'masquerade'
                              ? 'bg-amber-50 dark:bg-amber-900/20 text-amber-600 dark:text-amber-300 border-amber-200 dark:border-amber-800'
                              : 'bg-slate-100 dark:bg-slate-800 text-slate-500 dark:text-gray-400 border-slate-200 dark:border-slate-700'
                        }`}>
                          {iface.type || 'default'}
                        </span>
                      </td>
                      <td className="px-3 py-1.5 font-mono text-[10px] text-slate-600 dark:text-gray-300">
                        {iface.macAddress || '--'}
                      </td>
                      <td className="px-3 py-1.5">
                        {iface.model ? (
                          <span className="px-1.5 py-0.5 rounded bg-slate-100 dark:bg-slate-800 text-[9px] text-slate-500 dark:text-gray-400 border border-slate-200 dark:border-slate-700">
                            {iface.model}
                          </span>
                        ) : '--'}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* Clock & Timers */}
      {Object.keys(parsed.clock.timers).length > 0 && (
        <div>
          <SectionHeader title="Clock & Timers" />
          <div className="border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
            <div className="px-3 py-2 flex items-center gap-2 border-b border-slate-100 dark:border-slate-800">
              <span className="text-[10px] text-slate-400 dark:text-gray-500">Offset:</span>
              <span className="text-[11px] text-slate-700 dark:text-gray-200 font-semibold">
                {parsed.clock.offset || 'Not set'}
              </span>
            </div>
            <div className="flex flex-wrap gap-1.5 px-3 py-2">
              {Object.entries(parsed.clock.timers).map(([name, props]) => {
                const details = Object.entries(props)
                  .map(([k, v]) => `${k}: ${v}`)
                  .join(', ');
                return (
                  <span
                    key={name}
                    className="inline-flex items-center gap-1 px-2 py-0.5 rounded text-[10px] bg-slate-50 dark:bg-slate-800/50 text-slate-600 dark:text-gray-300 border border-slate-200 dark:border-slate-700"
                    title={details || name}
                  >
                    <span className="font-semibold">{name}</span>
                    {details && <span className="text-slate-400 dark:text-gray-500">({details})</span>}
                  </span>
                );
              })}
            </div>
          </div>
        </div>
      )}

      {/* Raw YAML toggle */}
      <div>
        <button
          onClick={() => setShowYaml(!showYaml)}
          className="flex items-center gap-1.5 text-[11px] text-slate-500 dark:text-gray-400 hover:text-slate-700 dark:hover:text-gray-200 transition-colors"
        >
          <svg
            className={`w-3.5 h-3.5 transition-transform ${showYaml ? 'rotate-90' : ''}`}
            fill="none" viewBox="0 0 24 24" stroke="currentColor"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
          <span className="font-medium">KubeVirt YAML</span>
        </button>
        {showYaml && (
          <div className="mt-2 border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
            <pre className="px-3 py-2 text-[10px] font-mono text-slate-600 dark:text-gray-300 bg-slate-50 dark:bg-slate-900/50 overflow-x-auto max-h-[400px] overflow-y-auto whitespace-pre">
              {parsed.rawYaml}
            </pre>
          </div>
        )}
      </div>
    </div>
  );
}

